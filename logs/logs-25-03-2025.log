{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T10:13:51.905Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T10:15:01.371Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T10:15:25.361Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T10:16:21.163Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T10:16:48.197Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T10:18:11.454Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T10:18:57.946Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T10:22:39.868Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T10:22:49.033Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T10:23:08.636Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T10:33:48.820Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T10:38:20.553Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T10:38:30.514Z"}
{"level":"info","message":"Router ------------admin login","timestamp":"2025-03-25T10:38:38.512Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T10:39:06.410Z"}
{"level":"info","message":"Router ------------admin login","timestamp":"2025-03-25T10:39:11.889Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T10:40:43.152Z"}
{"actual":false,"code":"ERR_ASSERTION","expected":true,"generatedMessage":false,"level":"error","message":"Server not running ---  Missing or undefined handler: POST /api/v1/Routes/addEmployee","operator":"==","stack":"AssertionError [ERR_ASSERTION]: Missing or undefined handler: POST /api/v1/Routes/addEmployee\n    at new module.exports.internals.Route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\route.js:72:14)\n    at internals.Server._addRoute (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:525:23)\n    at internals.Server.route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:518:22)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:12:14\n    at new Promise (<anonymous>)\n    at newRoutes.<anonymous> (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:10:12)\n    at Generator.next (<anonymous>)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:8:71\n    at new Promise (<anonymous>)\n    at __awaiter (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:4:12)","timestamp":"2025-03-25T10:41:53.397Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T10:42:27.862Z"}
{"level":"info","message":"Router ------------add employee","timestamp":"2025-03-25T10:42:28.621Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T10:50:21.011Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T11:53:35.676Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T11:53:53.368Z"}
{"level":"info","message":"Router ------------add employee","timestamp":"2025-03-25T11:53:55.230Z"}
{"level":"info","message":"Router ------------add employee","timestamp":"2025-03-25T11:54:16.113Z"}
{"level":"info","message":"Router ------------add employee","timestamp":"2025-03-25T11:54:18.401Z"}
{"level":"info","message":"Router ------------add employee","timestamp":"2025-03-25T11:55:01.032Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T11:58:25.494Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T11:58:41.297Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T11:59:29.281Z"}
{"level":"info","message":"Router ------------add employee","timestamp":"2025-03-25T12:00:05.427Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:01:01.777Z"}
{"level":"info","message":"Router ------------add employee","timestamp":"2025-03-25T12:01:05.803Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:20:48.702Z"}
{"level":"info","message":"Router ------------add employee","timestamp":"2025-03-25T12:21:03.553Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:21:27.666Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:21:32.480Z"}
{"actual":false,"code":"ERR_ASSERTION","expected":true,"generatedMessage":false,"level":"error","message":"Server not running ---  Cannot validate HEAD or GET request payload: GET /api/v1/Routes/getEmployee","operator":"==","stack":"AssertionError [ERR_ASSERTION]: Cannot validate HEAD or GET request payload: GET /api/v1/Routes/getEmployee\n    at new module.exports.internals.Route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\route.js:61:14)\n    at internals.Server._addRoute (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:525:23)\n    at internals.Server.route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:518:22)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:12:14\n    at new Promise (<anonymous>)\n    at newRoutes.<anonymous> (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:10:12)\n    at Generator.next (<anonymous>)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:8:71\n    at new Promise (<anonymous>)\n    at __awaiter (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:4:12)","timestamp":"2025-03-25T12:21:43.677Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:22:33.543Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:22:46.270Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:22:52.595Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:23:00.105Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:26:52.150Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:28:09.081Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:28:28.312Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:28:32.734Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:28:39.474Z"}
{"level":"error","message":"Server not running ---  Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m","stack":"Error: Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m\n    at Object.exports.apply (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\config.js:20:15)\n    at new module.exports.internals.Route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\route.js:83:32)\n    at internals.Server._addRoute (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:525:23)\n    at internals.Server.route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:518:22)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:12:14\n    at new Promise (<anonymous>)\n    at newRoutes.<anonymous> (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:10:12)\n    at Generator.next (<anonymous>)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:8:71\n    at new Promise (<anonymous>)","timestamp":"2025-03-25T12:28:58.918Z"}
{"level":"error","message":"Server not running ---  Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: {\n      \"type\": \"string\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {\n        \"presence\": \"required\"\n      },\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"replacements\": null\n      },\n      \"$_super\": {}\n    }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m","stack":"Error: Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: {\n      \"type\": \"string\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {\n        \"presence\": \"required\"\n      },\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"replacements\": null\n      },\n      \"$_super\": {}\n    }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m\n    at Object.exports.apply (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\config.js:20:15)\n    at new module.exports.internals.Route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\route.js:83:32)\n    at internals.Server._addRoute (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:525:23)\n    at internals.Server.route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:518:22)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:12:14\n    at new Promise (<anonymous>)\n    at newRoutes.<anonymous> (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:10:12)\n    at Generator.next (<anonymous>)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:8:71\n    at new Promise (<anonymous>)","timestamp":"2025-03-25T12:29:12.221Z"}
{"level":"error","message":"Server not running ---  Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m","stack":"Error: Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m\n    at Object.exports.apply (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\config.js:20:15)\n    at new module.exports.internals.Route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\route.js:83:32)\n    at internals.Server._addRoute (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:525:23)\n    at internals.Server.route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:518:22)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:12:14\n    at new Promise (<anonymous>)\n    at newRoutes.<anonymous> (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:10:12)\n    at Generator.next (<anonymous>)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:8:71\n    at new Promise (<anonymous>)","timestamp":"2025-03-25T12:29:25.297Z"}
{"level":"error","message":"Server not running ---  Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"authorization\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"optional\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m","stack":"Error: Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"authorization\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"optional\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m\n    at Object.exports.apply (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\config.js:20:15)\n    at new module.exports.internals.Route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\route.js:83:32)\n    at internals.Server._addRoute (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:525:23)\n    at internals.Server.route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:518:22)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:12:14\n    at new Promise (<anonymous>)\n    at newRoutes.<anonymous> (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:10:12)\n    at Generator.next (<anonymous>)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:8:71\n    at new Promise (<anonymous>)","timestamp":"2025-03-25T12:30:21.296Z"}
{"level":"error","message":"Server not running ---  Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {\n        \"unknown\": true\n      },\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"authorization\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"optional\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m","stack":"Error: Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {\n        \"unknown\": true\n      },\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"authorization\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"optional\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m\n    at Object.exports.apply (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\config.js:20:15)\n    at new module.exports.internals.Route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\route.js:83:32)\n    at internals.Server._addRoute (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:525:23)\n    at internals.Server.route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:518:22)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:12:14\n    at new Promise (<anonymous>)\n    at newRoutes.<anonymous> (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:10:12)\n    at Generator.next (<anonymous>)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:8:71\n    at new Promise (<anonymous>)","timestamp":"2025-03-25T12:30:33.590Z"}
{"level":"error","message":"Server not running ---  Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {\n        \"unknown\": true\n      },\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"authorization\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"optional\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m","stack":"Error: Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {\n        \"unknown\": true\n      },\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"authorization\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"optional\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m\n    at Object.exports.apply (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\config.js:20:15)\n    at new module.exports.internals.Route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\route.js:83:32)\n    at internals.Server._addRoute (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:525:23)\n    at internals.Server.route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:518:22)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:12:14\n    at new Promise (<anonymous>)\n    at newRoutes.<anonymous> (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:10:12)\n    at Generator.next (<anonymous>)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:8:71\n    at new Promise (<anonymous>)","timestamp":"2025-03-25T12:30:40.542Z"}
{"level":"error","message":"Server not running ---  Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {\n        \"unknown\": true\n      },\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"authorization\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"optional\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m","stack":"Error: Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {\n        \"unknown\": true\n      },\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"authorization\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"optional\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m\n    at Object.exports.apply (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\config.js:20:15)\n    at new module.exports.internals.Route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\route.js:83:32)\n    at internals.Server._addRoute (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:525:23)\n    at internals.Server.route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:518:22)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:12:14\n    at new Promise (<anonymous>)\n    at newRoutes.<anonymous> (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:10:12)\n    at Generator.next (<anonymous>)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:8:71\n    at new Promise (<anonymous>)","timestamp":"2025-03-25T12:30:47.747Z"}
{"level":"error","message":"Server not running ---  Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {\n        \"unknown\": true\n      },\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"authorization\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"optional\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m","stack":"Error: Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {\n        \"unknown\": true\n      },\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"authorization\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"optional\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m\n    at Object.exports.apply (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\config.js:20:15)\n    at new module.exports.internals.Route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\route.js:83:32)\n    at internals.Server._addRoute (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:525:23)\n    at internals.Server.route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:518:22)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:12:14\n    at new Promise (<anonymous>)\n    at newRoutes.<anonymous> (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:10:12)\n    at Generator.next (<anonymous>)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:8:71\n    at new Promise (<anonymous>)","timestamp":"2025-03-25T12:30:54.176Z"}
{"level":"error","message":"Server not running ---  Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {\n        \"unknown\": true\n      },\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"authorization\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"optional\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m","stack":"Error: Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {\n        \"unknown\": true\n      },\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"authorization\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"optional\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m\n    at Object.exports.apply (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\config.js:20:15)\n    at new module.exports.internals.Route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\route.js:83:32)\n    at internals.Server._addRoute (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:525:23)\n    at internals.Server.route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:518:22)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:12:14\n    at new Promise (<anonymous>)\n    at newRoutes.<anonymous> (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:10:12)\n    at Generator.next (<anonymous>)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:8:71\n    at new Promise (<anonymous>)","timestamp":"2025-03-25T12:31:05.442Z"}
{"level":"error","message":"Server not running ---  Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {\n        \"unknown\": true\n      },\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"authorization\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"optional\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m","stack":"Error: Invalid routeConfig options (post /api/v1/Routes/viewProfile) {\n  \"cors\": {\n    \"origin\": [\n      \"*\"\n    ],\n    \"headers\": [\n      \"Accept\",\n      \"Authorization\",\n      \"Content-Type\",\n      \"If-None-Match\"\n    ],\n    \"exposedHeaders\": [\n      \"WWW-Authenticate\",\n      \"Server-Authorization\"\n    ],\n    \"credentials\": true,\n    \"maxAge\": 86400,\n    \"additionalHeaders\": [],\n    \"additionalExposedHeaders\": [],\n    \"preflightStatusCode\": 200\n  },\n  \"security\": {\n    \"hsts\": 15768000,\n    \"xframe\": \"deny\",\n    \"xss\": \"disabled\",\n    \"noOpen\": true,\n    \"noSniff\": true,\n    \"referrer\": false\n  },\n  \"payload\": {\n    \"maxBytes\": 5242880,\n    \"output\": \"data\",\n    \"parse\": true,\n    \"multipart\": false,\n    \"protoAction\": \"error\",\n    \"maxParts\": 1000,\n    \"uploads\": \"C:\\\\Users\\\\INDHU\\\\AppData\\\\Local\\\\Temp\",\n    \"failAction\": \"error\",\n    \"timeout\": 10000,\n    \"defaultContentType\": \"application/json\",\n    \"compression\": {}\n  },\n  \"cache\": {\n    \"statuses\": [\n      200,\n      204\n    ],\n    \"otherwise\": \"no-cache\"\n  },\n  \"compression\": {},\n  \"ext\": {},\n  \"files\": {\n    \"relativeTo\": \".\"\n  },\n  \"json\": {\n    \"replacer\": null,\n    \"space\": null,\n    \"suffix\": null,\n    \"escape\": false\n  },\n  \"log\": {\n    \"collect\": false\n  },\n  \"response\": {\n    \"disconnectStatusCode\": 499,\n    \"emptyStatusCode\": 204,\n    \"failAction\": \"error\",\n    \"ranges\": true\n  },\n  \"state\": {\n    \"parse\": true,\n    \"failAction\": \"error\"\n  },\n  \"timeout\": {\n    \"server\": false\n  },\n  \"validate\": {\n    \"failAction\": \"error\",\n    \"options\": {},\n    \"payload\": {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {},\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"refUserId\",\n            \"schema\": {\n              \"type\": \"number\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [\n                {\n                  \"name\": \"integer\",\n                  \"_resolve\": [],\n                  \"method\": \"integer\"\n                }\n              ],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"required\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    },\n    \"Headers\" \u001b[31m[1]\u001b[0m: {\n      \"type\": \"object\",\n      \"$_root\": {\n        \"_types\": {},\n        \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n        \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n        \"version\": \"17.13.3\",\n        \"cache\": {\n          \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n        },\n        \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n        \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n        \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n        \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n        \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n        \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n        \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n        \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n        \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n        \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n        \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n        \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n        \"override\": Symbol(override),\n        \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n        \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n        \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n        \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n        \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n        \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n        \"default\": {\n          \"_types\": {},\n          \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n          \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n          \"version\": \"17.13.3\",\n          \"cache\": {\n            \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n          },\n          \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n          \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n          \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n          \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n          \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n          \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n          \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n          \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n          \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n          \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n          \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n          \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n          \"override\": Symbol(override),\n          \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n          \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n          \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n          \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n          \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n          \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n        }\n      },\n      \"$_temp\": {\n        \"ruleset\": false,\n        \"whens\": {}\n      },\n      \"_ids\": {\n        \"_byId\": {},\n        \"_byKey\": {},\n        \"_schemaChain\": false\n      },\n      \"_preferences\": null,\n      \"_valids\": null,\n      \"_invalids\": null,\n      \"_rules\": [],\n      \"_singleRules\": {},\n      \"_refs\": {\n        \"refs\": []\n      },\n      \"_flags\": {\n        \"unknown\": true\n      },\n      \"_cache\": null,\n      \"$_terms\": {\n        \"alterations\": null,\n        \"examples\": null,\n        \"externals\": null,\n        \"metas\": [],\n        \"notes\": [],\n        \"shared\": null,\n        \"tags\": [],\n        \"whens\": null,\n        \"dependencies\": null,\n        \"keys\": [\n          {\n            \"key\": \"authorization\",\n            \"schema\": {\n              \"type\": \"string\",\n              \"$_root\": {\n                \"_types\": {},\n                \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                \"version\": \"17.13.3\",\n                \"cache\": {\n                  \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                },\n                \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                \"override\": Symbol(override),\n                \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                \"untrace\": () => {\\n\\n        root._tracer = null;\\n    },\n                \"default\": {\n                  \"_types\": {},\n                  \"alternatives\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"any\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"array\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"boolean\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"date\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"function\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"link\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"number\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"object\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"string\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"symbol\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"binary\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"allow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"custom\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"disallow\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"equal\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"exist\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"forbidden\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"invalid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"not\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"only\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"optional\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"options\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"prefs\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"preferences\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"required\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"strip\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"valid\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"when\": function (...args) {\\n\\n            return this.any()[method](...args);\\n        },\n                  \"ValidationError\": \"[class extends Error {\\n\\n    constructor(message, details, original) {\\n\\n        super(message);\\n        this._original = original;\\n        this.details = details;\\n    }\\n\\n    static isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }\\n}]\",\n                  \"version\": \"17.13.3\",\n                  \"cache\": {\n                    \"provision\": \"[provision(options) {\\n\\n        return new internals.Cache(options);\\n    }]\"\n                  },\n                  \"assert\": \"[assert(value, schema, ...args /* [message], [options] */) {\\n\\n        internals.assert(value, schema, true, args);\\n    }]\",\n                  \"attempt\": \"[attempt(value, schema, ...args /* [message], [options] */) {\\n\\n        return internals.assert(value, schema, false, args);\\n    }]\",\n                  \"build\": \"[build(desc) {\\n\\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\\n        return Manifest.build(this, desc);\\n    }]\",\n                  \"checkPreferences\": \"[checkPreferences(prefs) {\\n\\n        Common.checkPreferences(prefs);\\n    }]\",\n                  \"compile\": \"[compile(schema, options) {\\n\\n        return Compile.compile(this, schema, options);\\n    }]\",\n                  \"defaults\": \"[defaults(modifier) {\\n\\n        Assert(typeof modifier === 'function', 'modifier must be a function');\\n\\n        const joi = Object.assign({}, this);\\n        for (const type of joi._types) {\\n            const schema = modifier(joi[type]());\\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\\n\\n            joi[type] = function (...args) {\\n\\n                return internals.generate(this, schema, args);\\n            };\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"expression\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"extend\": \"[extend(...extensions) {\\n\\n        Common.verifyFlat(extensions, 'extend');\\n\\n        Schemas = Schemas || require('./schemas');\\n\\n        Assert(extensions.length, 'You need to provide at least one extension');\\n        this.assert(extensions, Schemas.extensions);\\n\\n        const joi = Object.assign({}, this);\\n        joi._types = new Set(joi._types);\\n\\n        for (let extension of extensions) {\\n            if (typeof extension === 'function') {\\n                extension = extension(joi);\\n            }\\n\\n            this.assert(extension, Schemas.extension);\\n\\n            const expanded = internals.expandExtension(extension, joi);\\n            for (const item of expanded) {\\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\\n\\n                const base = item.base || this.any();\\n                const schema = Extend.type(base, item);\\n\\n                joi._types.add(item.type);\\n                joi[item.type] = function (...args) {\\n\\n                    return internals.generate(this, schema, args);\\n                };\\n            }\\n        }\\n\\n        return joi;\\n    }]\",\n                  \"isError\": \"[isError(err) {\\n\\n        return err instanceof exports.ValidationError;\\n    }]\",\n                  \"isExpression\": \"[isTemplate(template) {\\n\\n        return template ? !!template[Common.symbols.template] : false;\\n    }]\",\n                  \"isRef\": function (ref) {\\n\\n    return ref ? !!ref[Common.symbols.ref] : false;\\n},\n                  \"isSchema\": function (schema, options = {}) {\\n\\n    const any = schema && schema[exports.symbols.any];\\n    if (!any) {\\n        return false;\\n    }\\n\\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\\n    return true;\\n},\n                  \"in\": \"[in(...args) {\\n\\n        return Ref.in(...args);\\n    }]\",\n                  \"override\": Symbol(override),\n                  \"ref\": \"[ref(...args) {\\n\\n        return Ref.create(...args);\\n    }]\",\n                  \"types\": \"[types() {\\n\\n        const types = {};\\n        for (const type of this._types) {\\n            types[type] = this[type]();\\n        }\\n\\n        for (const target in internals.aliases) {\\n            types[target] = this[target]();\\n        }\\n\\n        return types;\\n    }]\",\n                  \"alt\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"bool\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"func\": function (...args) {\\n\\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\\n            return internals.generate(this, internals.types[type], args);\\n        },\n                  \"x\": \"[expression(...args) {\\n\\n        return new Template(...args);\\n    }]\",\n                  \"trace\": function () {\\n\\n        root._tracer = root._tracer || new internals.Tracer();\\n        return root._tracer;\\n    },\n                  \"untrace\": () => {\\n\\n        root._tracer = null;\\n    }\n                }\n              },\n              \"$_temp\": {\n                \"ruleset\": false,\n                \"whens\": {}\n              },\n              \"_ids\": {\n                \"_byId\": {},\n                \"_byKey\": {},\n                \"_schemaChain\": false\n              },\n              \"_preferences\": null,\n              \"_valids\": null,\n              \"_invalids\": null,\n              \"_rules\": [],\n              \"_singleRules\": {},\n              \"_refs\": {\n                \"refs\": []\n              },\n              \"_flags\": {\n                \"presence\": \"optional\"\n              },\n              \"_cache\": null,\n              \"$_terms\": {\n                \"alterations\": null,\n                \"examples\": null,\n                \"externals\": null,\n                \"metas\": [],\n                \"notes\": [],\n                \"shared\": null,\n                \"tags\": [],\n                \"whens\": null,\n                \"replacements\": null\n              },\n              \"$_super\": {}\n            }\n          }\n        ],\n        \"patterns\": null,\n        \"renames\": null\n      },\n      \"$_super\": {\n        \"default\": function () { [native code] }\n      }\n    }\n  },\n  \"pre\": [\n    {\n      \"method\": function validateToken(request, h) {\\n    const authHeader = request.headers.authorization;\\n    console.log('authHeader line ----- 66  \\\\n \\\\n', authHeader);\\n    if (!authHeader) {\\n        return h.response({ error: \\\"Token missing\\\" }).code(401).takeover();\\n    }\\n    const token = authHeader.split(\\\" \\\")[1];\\n    console.log('token', token);\\n    const decodedToken = decodeToken(token);\\n    console.log('decodedToken', decodedToken);\\n    if (\\\"error\\\" in decodeToken) {\\n        return h\\n            .response((0, encrypt_1.encrypt)({\\n            token: false,\\n            message: decodedToken.error,\\n        }, true))\\n            .code(200)\\n            .takeover();\\n    }\\n    request.plugins.token = decodedToken;\\n    console.log(\\\"request.plugins.token\\\", request.plugins.token);\\n    return h.continue;\\n},\n      \"assign\": \"token\"\n    }\n  ],\n  \"description\": \"view profile\",\n  \"tags\": [\n    \"api\",\n    \"Users\"\n  ],\n  \"auth\": false\n}\n\u001b[31m\n[1] \"validate.Headers\" is not allowed\u001b[0m\n    at Object.exports.apply (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\config.js:20:15)\n    at new module.exports.internals.Route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\route.js:83:32)\n    at internals.Server._addRoute (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:525:23)\n    at internals.Server.route (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\node_modules\\@hapi\\hapi\\lib\\server.js:518:22)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:12:14\n    at new Promise (<anonymous>)\n    at newRoutes.<anonymous> (C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:10:12)\n    at Generator.next (<anonymous>)\n    at C:\\Users\\INDHU\\Desktop\\projects\\JP-Backend\\src\\api\\admin\\routes.ts:8:71\n    at new Promise (<anonymous>)","timestamp":"2025-03-25T12:32:16.539Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:33:12.064Z"}
{"level":"info","message":"Router ------------view profile","timestamp":"2025-03-25T12:33:46.080Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:34:39.957Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:34:51.567Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:34:55.412Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:35:10.518Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:35:22.137Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:35:40.832Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:36:01.541Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:36:14.205Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:37:46.170Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:38:07.164Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:38:27.249Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:38:57.908Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:39:28.867Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:41:05.105Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:41:16.899Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:41:44.792Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:42:21.732Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:42:41.715Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:42:48.519Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:44:50.038Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:45:04.709Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:45:13.672Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:46:41.485Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:51:53.094Z"}
{"level":"info","message":"Server running --- from server.ts","timestamp":"2025-03-25T12:52:22.500Z"}
